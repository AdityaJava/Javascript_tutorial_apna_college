JavaScript Execution Context Explained

When JavaScript code runs, it does so inside something called an
Execution Context.
This determines how variables, functions, and objects are stored and
executed.

There are always two main phases when JavaScript code is executed:

1.  Memory Creation Phase (Creation Phase)
2.  Execution Phase

Let‚Äôs go step by step with an example.

  --------------
  Example Code
  --------------

    // Code starts
    let val1 = 10;
    let val2 = 5;

    function addNum(n1, n2) {
        let total = n1 + n2;
        return total;
    }

    let r1 = addNum(val1, val2);
    let r2 = addNum(9, 8);
    // Code ends

  -------------------------------------------
  Global Execution Context (GEC)
  -------------------------------------------
  Whenever JS runs a file, the Global
  Execution Context (GEC) is created. This
  has two phases: Memory Creation Phase and
  Execution Phase.

  ### Step 1. Global Execution / Global
  Environment - The code is allocated inside
  the this keyword (browser ‚Üí window, NodeJS
  ‚Üí {}). - JavaScript engine creates the
  Global Object + this + outer environment.
  -------------------------------------------

Step 2. Memory Creation Phase (for Global Scope)

In this phase, memory is allocated for variables and functions but not
executed yet.

-   val1 ‚Üí undefined
-   val2 ‚Üí undefined
-   addNum ‚Üí Function definition is stored in memory
-   r1 ‚Üí undefined
-   r2 ‚Üí undefined

  -------------------------------------------
  Step 3. Execution Phase (for Global Scope)
  -------------------------------------------
  Now line-by-line execution happens.

  - val1 = 10 - val2 = 5 - At line
  let r1 = addNum(val1, val2); - A new
  Function Execution Context (FEC) is created
  for addNum. - r1 = 15 - At line
  let r2 = addNum(9, 8); - Another new
  Function Execution Context (FEC) is
  created. - r2 = 17

  So after execution: - val1 = 10 -
  val2 = 5 - r1 = 15 - r2 = 17
  -------------------------------------------

Function Execution Context (FEC)

Whenever a function is called, a new Function Execution Context is
created.
This again has two phases.

Example: Function call addNum(val1, val2)

1.  Memory Creation Phase (inside function)
    -   n1 ‚Üí undefined
    -   n2 ‚Üí undefined
    -   total ‚Üí undefined
2.  Execution Phase
    -   n1 = 10
    -   n2 = 5
    -   total = 15
    -   return total ‚Üí 15 (this value is sent back to Global Execution
        Context)

‚ö†Ô∏è Once the function finishes execution, the Function Execution Context
is destroyed (garbage collected).

  -------------------------------------------
  Another Function Call Example: addNum(9, 8)
  -------------------------------------------
           üîë Key Points to Remember

  -------------------------------------------

1.  Global Execution Context (GEC) is created once when JS file starts
    execution.
2.  Each function call creates a new Function Execution Context (FEC).
3.  Each execution context has:
    -   Memory Phase ‚Üí variables initialized to undefined, functions
        stored as definitions.
    -   Execution Phase ‚Üí actual assignment and execution happen.
4.  Function Execution Context is deleted after execution, but Global
    Execution Context remains until program ends.

  ---------------------------------------
  üìå Visual Representation (Simplified)
  ---------------------------------------

Global Execution Context (GEC)

Memory Phase: val1 ‚Üí undefined val2 ‚Üí undefined addNum ‚Üí function {} r1
‚Üí undefined r2 ‚Üí undefined

Execution Phase: val1 = 10 val2 = 5 r1 = addNum(10, 5) ‚Üí 15 r2 =
addNum(9, 8) ‚Üí 17

Function Execution Context (FEC - for addNum)

Memory Phase: n1 ‚Üí undefined n2 ‚Üí undefined total ‚Üí undefined

Execution Phase: n1 = value passed n2 = value passed total = n1 + n2
return total ‚Üí back to GEC
